<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UGOKU Lab</title>
    <link href="styles/main.css" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/cbd15fcef1.js" crossorigin="anonymous"></script>
    
</head>

<body>

    <header class="header">
        <a href="index.html" style="text-decoration: none; color: white;">
            <h1>UGOKU Lab</h1>
        </a>
        <div class="social-icons">
            <a href="https://twitter.com/UGOKU_Lab" target="_blank" title="Twitter"><i class="fa-brands fa-x-twitter"></i>
            <a href="https://github.com/UGOKU-Lab" target="_blank" title="GitHub"><i class="fab fa-github"></i></a>
        </div>
    </header>

    <div class="content-container">
    
        <h1>ジャイロ効果を感じるやつ</h1>
                
        <figure class="video">
            <iframe width="853" height="480" src="https://www.youtube.com/embed/c5LMpY1wxpU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </figure>

        <!-- 目次 -->
        <nav class="toc" aria-label="目次">
            <strong>目次</strong>
            <ul>
                <li><a href="#overview">概要</a></li>
                <li><a href="#cad-gen2">CAD</a></li>
                <li><a href="#specs">諸元</a></li>
                <li><a href="#system">システム構成</a></li>
                <li><a href="#rotor">回転部</a></li>
                <li><a href="#housing">筐体</a></li>
                <li><a href="#first-gen">初代</a></li>
            </ul>
            <div class="toc-actions">
                <button type="button" class="toc-btn" data-action="expand">すべて開く</button>
                <button type="button" class="toc-btn" data-action="collapse">すべて閉じる</button>
            </div>
        </nav>

        <div class="project">
            <div class="project-content">
                <div class="buttons-row">
                    <a href="https://github.com/UGOKU-Lab/FeelGyro_M5_ArduinoIDE" target="_blank" class="orange-button">M5 Stick Program</a>
                    <a href="https://github.com/UGOKU-Lab/FeelGyro2_STM_MD_Controller_I2C" target="_blank" class="orange-button">Motor Controller Board Program</a>
                </div>
            </div>
        </div>
        
        <section id="overview">
            <h2>概要</h2>
            <p>
                手にもって動かすと不思議な感覚、地球ゴマとしても遊べる。高速で回転する円盤を手のひらサイズのキューブに収めた、誰でも楽しめる体験型デバイスです。
            </p>
            <p>
                「ジャイロ効果を感じるやつ」はNT東京2023で人気を博した体験をベースに、ブラシレスDCモーターのダイレクトドライブ化で静かで滑らか、さらにコンパクトに。ジャイロ効果体験度は大幅UP。電動地球ゴマとしても楽しめます。
            </p>
        </section>

        <section id="cad-gen2">
            <h2>CAD</h2>
            <div class="embed-center">
                <iframe src="https://outlook187340.autodesk360.com/shares/public/SH286ddQT78850c0d8a41a7502d607ea7472?mode=embed" width="1024" height="768" allowfullscreen="true" webkitallowfullscreen="true" mozallowfullscreen="true"  frameborder="0"></iframe>
            </div>
        </section>

        <!-- 諸元（静的表） -->
        <section id="specs">
            <h2>諸元</h2>
            <div class="table-scroll">
                <table class="excel-table">
                    <tbody>
                        <tr>
                            <th>サイズ</th>
                            <td>105 × 105 × 105 mm</td>
                        </tr>
                        <tr>
                            <th>本体重量</th>
                            <td>2 kg</td>
                        </tr>
                        <tr>
                            <th>フライホイール重量</th>
                            <td>1. 05 kg</td>
                        </tr>
                        <tr>
                            <th>フライホイール慣性モーメント</th>
                            <td>1. 3×10<sup>-3</sup> kg・m<sup>2</sup></td>
                        </tr>
                        <tr>
                            <th>モータ型式</th>
                            <td>maxon EC frameless 45 flat 50W 574402</td>
                        </tr>
                        <tr>
                            <th>消費電力</th>
                            <td>定常回転時 6.2 W / 加速時(最大) 50 W</td>
                        </tr>
                        <tr>
                            <th>バッテリ容量</th>
                            <td>1200mAh</td>
                        </tr>
                        <tr>
                            <th>連続稼働時間</th>
                            <td>4 h</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- システム構成（常時表示） -->
        <section id="system">
            <h2>システム構成</h2>
            <div class="embed-center">
                <img src="images/GYRO/Gen2_system_diagram.png" alt="システム構成図" style="max-width:100%; height:auto;" />
            </div>
        </section>

        <!-- 回転部（常時表示・部品表） -->
        <section id="rotor" class="structure-item">
            <h2>回転部</h2>
            <p>インホイール・ダイレクトドライブ構造</p>
            <div class="embed-center">
                <img src="images/GYRO/Fly-wheel_unit.png" alt="フライホイールユニット" style="max-width:70%; height:auto;" />
            </div>
            <h3>部品表（フライホイール回転部 全体）</h3>
            <div class="table-scroll js-bom" data-excel="images/GYRO/Gen2_BOM.xlsx" data-table="fly-wheel_unit" data-columns="Balloon|Partname|Material|Surface Finishing|Part Number|Supplier|Unit Price|QTY|Price|Lead Time|Note"></div>
        </section>

        <!-- 筐体（概要常時表示＋詳細折りたたみ） -->
        <section id="housing" class="structure-item">
            <h2>筐体</h2>
                <p>ポリカーボネート製筐体</p>
                <h3>部品表（筐体）</h3>
                <div class="table-scroll js-bom" data-excel="images/GYRO/Gen2_BOM.xlsx" data-table="enclosure" data-columns="Balloon|Partname|Material|Surface Finishing|Part Number|Supplier|Unit Price|QTY|Price|Lead Time|Note"></div>
    </section>

        <section id="first-gen">
            <h2>初代</h2>
            <p>
                高速で回転する円盤を手のひらサイズのキューブに収めた、誰でも楽しめる体験型デバイス。
            </p>
            <figure class="video">
                <video controls src="https://tomohiroaoki.com/wp-content/uploads/2023/05/gyro_small.mp4"></video>
            </figure>
        </section>

        <br>
        <br>

    </div>
    
    <footer>
        <p>&copy; 2025 UGOKU Lab</p>
    </footer>

    <script>
    // TOC: open target section and manage expand/collapse for rotor & housing accordions only
    (function() {
        const toc = document.querySelector('.toc');
        const detailsList = Array.from(document.querySelectorAll('#rotor details.accordion, #housing details.accordion'));

        function openFromHash() {
            const id = decodeURIComponent(location.hash.replace('#',''));
            if (!id) return;
            const target = document.getElementById(id);
            if (target && target.tagName.toLowerCase() === 'details') {
                target.open = true;
                // scroll after open to ensure correct position
                setTimeout(() => target.scrollIntoView({behavior: 'smooth', block: 'start'}), 0);
            } else if (target) {
                const parentDetails = target.closest('details');
                if (parentDetails) parentDetails.open = true;
                setTimeout(() => target.scrollIntoView({behavior: 'smooth', block: 'start'}), 0);
            }
        }

        if (toc) {
            toc.addEventListener('click', (e) => {
                const a = e.target.closest('a');
                if (a && a.getAttribute('href')?.startsWith('#')) {
                    e.preventDefault();
                    const id = a.getAttribute('href').slice(1);
                    const d = document.getElementById(id);
                    if (d && d.tagName.toLowerCase() === 'details') d.open = true;
                    history.pushState(null, '', '#' + id);
                    openFromHash();
                }
                const btn = e.target.closest('.toc-btn');
                if (btn) {
                    const act = btn.dataset.action;
                    detailsList.forEach(d => d.open = (act === 'expand'));
                }
            });
        }
        window.addEventListener('hashchange', openFromHash);
        // open on initial load if hash exists
        if (location.hash) openFromHash();
    })();
    </script>

    <script>
    // Excel BOM loader: fetch and render BOM tables (supports category or named table/sheet)
    (function() {
        const targets = Array.from(document.querySelectorAll('.js-bom[data-excel]'));
        if (!targets.length) return;

        // Load SheetJS dynamically
        function loadSheetJS() {
            return new Promise((resolve, reject) => {
                if (window.XLSX) return resolve();
                const s = document.createElement('script');
                s.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('SheetJSの読み込みに失敗'));
                document.head.appendChild(s);
            });
        }

        async function fetchWorkbook(url) {
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error('BOMファイルの取得に失敗');
            const buf = await res.arrayBuffer();
            return XLSX.read(buf, { type: 'array' });
        }

        function normalize(v) { return (v ?? '').toString().trim(); }

        // Header normalization utilities (for robust matching of Japanese/EN headers)
        function toHankaku(str) {
            // Convert full-width alphanumerics and symbols to half-width
            return str.replace(/[！-～]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
                      .replace(/　/g, ' ');
        }
        function normalizeHeader(str) {
            if (str == null) return '';
            const s = toHankaku(String(str))
                .toLowerCase()
                .replace(/[\s_\-]+/g, '')
                .replace(/[()（）\[\]【】]/g, '');
            return s;
        }
        function isCurrencyColName(name) {
            const n = normalizeHeader(name);
            return n === 'unitprice' || n === 'price';
        }

        // Canonical column keys and synonyms
        const COLUMN_SYNONYMS = {
            baloon: ['baloon','balloon','図番','番号','バルーン','ばるーん'],
            partName: ['partname','部品名','品名','品目','パーツ名','名称','なまえ'],
            unitPrice: ['unitprice','price','単価','価格','値段','prc'],
            qty: ['qty','quantity','数量','数','個数','個'],
            material: ['material','材質','材料'],
            plating: ['plating','表面処理','メッキ','めっき','表面'],
            partNumber: ['partnumber','型番','形番','型式','品番','pn','p/n','part no','partno','型號','partcode','model','modelno','model number'],
            note: ['note','備考','メモ','注釈','remarks','comment','コメント']
        };

        const DEFAULT_HEADERS = [
            { label: 'Baloon', key: 'baloon' },
            { label: 'Part Name', key: 'partName' },
            { label: 'Unit Price', key: 'unitPrice' },
            { label: 'QTY', key: 'qty' },
            { label: '全額', key: 'total' },
            { label: 'Material', key: 'material' },
            { label: 'Plating', key: 'plating' }
        ];

        function buildResolver(rows) {
            const firstKeys = Object.keys(rows[0] || {});
            // Map actual header -> normalized
            const actualToNorm = new Map(firstKeys.map(k => [k, normalizeHeader(k)]));
            // Build canonical -> actual map
            const canonicalToActual = new Map();
            for (const [canonical, synonyms] of Object.entries(COLUMN_SYNONYMS)) {
                const normSet = new Set(synonyms.map(normalizeHeader).concat([normalizeHeader(canonical)]));
                const hit = firstKeys.find(k => normSet.has(actualToNorm.get(k)));
                if (hit) canonicalToActual.set(canonical, hit);
            }
            // Fallback: if a canonical key exactly exists among actual headers
            for (const k of firstKeys) {
                const norm = actualToNorm.get(k);
                for (const canonical of Object.keys(COLUMN_SYNONYMS)) {
                    if (!canonicalToActual.has(canonical) && norm === normalizeHeader(canonical)) {
                        canonicalToActual.set(canonical, k);
                    }
                }
            }
            function resolve(canonical) {
                return canonicalToActual.get(canonical) || null;
            }
            return { resolve };
        }

        function detectCategoryKey(rows) {
            const sample = rows[0] || {};
            const keys = Object.keys(sample);
            const normKeys = keys.map(k => ({ k, n: normalizeHeader(k) }));
            const cands = ['分類','カテゴリ','カテゴリー','category','分類1'].map(normalizeHeader);
            const hit = normKeys.find(obj => cands.some(c => obj.n.includes(c)));
            return hit ? hit.k : (keys[0] || '分類');
        }

        function renderTable(container, rows) {
            if (!rows.length) {
                container.innerHTML = '<div style="padding:8px;color:#666;">該当する部品はありません。</div>';
                return false;
            }
            // Build resolver for header variations
            const resolver = buildResolver(rows);

            // Allow explicit column selection via data-columns attribute.
            // Format examples:
            //   data-columns="baloon,partName,unitPrice,qty,total,material,plating"
            //   data-columns="図番,部品名,単価,数量,total,材質,表面処理"  (actual header labels also OK)
            //   data-columns="No:baloon|品名:partName|単価:unitPrice|数量:qty|合計:total"
            const colsAttr = container.getAttribute('data-columns');
            let specHeaders;
            if (colsAttr) {
                const parts = colsAttr.split(/[|,]/).map(s => s.trim()).filter(Boolean);
                specHeaders = parts.map(p => {
                    let label, token;
                    if (p.includes(':') || p.includes('=')) {
                        const sep = p.includes(':') ? ':' : '=';
                        [label, token] = p.split(sep).map(s => s.trim());
                    } else {
                        token = p; label = null;
                    }
                    const n = normalizeHeader(token);
                    // 'total' is a virtual column
                    if (n === 'total' || n === '全額' || n === '合計' || n === 'ごうけい') {
                        return { label: label || '全額', key: '__total__' };
                    }
                    // Try resolve by canonical key first
                    const canonical = Object.keys(COLUMN_SYNONYMS).find(c => normalizeHeader(c) === n || COLUMN_SYNONYMS[c].map(normalizeHeader).includes(n));
                    const actual = canonical ? resolver.resolve(canonical) : null;
                    // If not found, try direct match to actual header
                    const keys = Object.keys(rows[0] || {});
                    const direct = keys.find(k => normalizeHeader(k) === n) || null;
                    const finalKey = actual || direct;
                    return { label: label || (canonical ? DEFAULT_HEADERS.find(h => h.key === canonical)?.label : (direct || token)), key: finalKey };
                });
            }

            // Default headers if no explicit spec provided
            const headers = specHeaders || DEFAULT_HEADERS.map(h => ({ label: h.label, key: h.key === 'total' ? '__total__' : resolver.resolve(h.key) }));

            // Filter out columns that couldn't be resolved except total which is computed
            const activeHeaders = headers.filter(h => h.key || h.key === '__total__');

            const thead = '<thead><tr>' + activeHeaders.map(h => `<th>${h.label}</th>`).join('') + '</tr></thead>';
            const tbody = '<tbody>' + rows.map(r => {
                const keyUnitPrice = resolver.resolve('unitPrice');
                const keyQty = resolver.resolve('qty');
                const rawUnitPrice = keyUnitPrice ? (r[keyUnitPrice] ?? '').toString() : '';
                const unitPrice = keyUnitPrice ? parseFloat(rawUnitPrice.replace(/[^0-9.\-]/g,'')) : NaN;
                const qty = keyQty ? parseFloat((r[keyQty] ?? '').toString().replace(/[^0-9.\-]/g,'')) : NaN;
                const total = (!isNaN(unitPrice) && !isNaN(qty)) ? (unitPrice * qty) : '';
                const yen = new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY', maximumFractionDigits: 0 });
                return '<tr>' + activeHeaders.map(h => {
                    if (h.key === '__total__') {
                        return `<td>${total === '' ? '' : yen.format(total)}</td>`;
                    }
                    // Currency format for Unit Price or Price columns
                    if (h.key && isCurrencyColName(h.key)) {
                        const raw = (r[h.key] ?? '').toString();
                        const num = parseFloat(raw.replace(/[^0-9.\-]/g,''));
                        return `<td>${isNaN(num) ? normalize(raw) : yen.format(num)}</td>`;
                    }
                    return `<td>${normalize(r[h.key])}</td>`;
                }).join('') + '</tr>';
            }).join('') + '</tbody>';
            container.innerHTML = `<table class="excel-table">${thead}${tbody}</table>`;
            return true;
        }

    // No fallback UI: on failure, leave the container empty

        function rowsFromTarget(wb, el) {
            const tableName = el.getAttribute('data-table');
            try {
                if (tableName && wb) {
                    // Try defined names first (named range)
                    const names = (wb.Workbook && wb.Workbook.Names) || [];
                    const hit = names.find(n => (n.Name || '').toString().trim() === tableName);
                    if (hit && hit.Ref) {
                        const ref = hit.Ref.replace(/\$/g, ''); // remove $ anchors
                        const [sheetName, a1] = ref.split('!');
                        const sheet = wb.Sheets[sheetName.replace(/^'/, '').replace(/'$/, '')] || wb.Sheets[wb.SheetNames[0]];
                        const rows = XLSX.utils.sheet_to_json(sheet, { defval: '', range: a1 });
                        return rows;
                    }
                    // Fallback: if a sheet exists with this name, use it
                    if (wb.Sheets[tableName]) {
                        return XLSX.utils.sheet_to_json(wb.Sheets[tableName], { defval: '' });
                    }
                }
                // Default: first sheet
                const first = wb.Sheets[wb.SheetNames[0]];
                return XLSX.utils.sheet_to_json(first, { defval: '' });
            } catch (e) {
                console.warn('rowsFromTarget error:', e);
                return [];
            }
        }

        (async () => {
            try {
                await loadSheetJS();
                // Resolve absolute URLs and group targets by file to avoid multiple fetches
                const byFile = targets.reduce((m, el) => {
                    const raw = el.getAttribute('data-excel');
                    const abs = new URL(raw, location.href).href; // always resolve relative to current page
                    (m[abs] ||= []).push(el);
                    return m;
                }, {});

                for (const [url, els] of Object.entries(byFile)) {
                    let wb;
                    try {
                        wb = await fetchWorkbook(url);
                    } catch (e) { wb = null; }
                    for (const el of els) {
                        if (!wb) { continue; }
                        let rows = rowsFromTarget(wb, el);
                        const catsAttr = el.getAttribute('data-category');
                        if (catsAttr) {
                            const cats = catsAttr.split('|').map(s => s.trim()).filter(Boolean);
                            const catKey = detectCategoryKey(rows);
                            rows = rows.filter(r => cats.includes(normalize(r[catKey])));
                        }
                        renderTable(el, rows);
                    }
                }
            } catch (err) {
                // Fail silently; fallbacks remain visible
                console.warn(err);
            }
        })();
    })();
    </script>
</body>
</html>
